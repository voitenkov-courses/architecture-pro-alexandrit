# Архитектурное решение по кешированию

## Мотивация

Внедрение кэширования позволит повысить пропускную способность и отзывчивость системы.
Кэшировать лучше данные, которые часто запрашиваются:
* товары из интернет-магазина (Internet Shop)
* текущий список заказов в работе (MES)

## Предлагаемое решение

### Для товаров из магазина

Для товаров из магазина можно применить в первую очередь клиентское кэширование, так как оно не требует сложной реализации. Если это не улучшит ситуацию, то можно применить серверное кэширование, лучше подойдет паттерн Cache Aside - это самый простой надежный вариант. Кэширование на запись здесь точно не подходят, а другие паттерны для чтения Read-Through и Refresh-Ahead чувствительны к ошибкам, и лучше пусть будет местами хуже отзывчивость, чем если пользователь увидит пустую страницу.

### Для текущего списка заказов в работе (или с другими статусами)

Если заказы отображаются постранично, то список из первой страницы. Как вариант, можно продумать кэширование следующей по порядку страницы с заказами в фоне (упреждающее кэширование). Идеально подойдет паттерн Refresh-Ahead, а для запроса первой страницы можно прогреть кэш данными первой страницы по наиболее популярным и часто запрашиваемым запросам. Историю и статистику запросов можно сохранять и обрабатывать. Возможные ошибки - не помеха, так как этими данными пользуются операторы, а не клиенты.

Диаграмма последовательности обработки заказа:

![order_sequence](order_sequence.png)

### Стратегии инвалидации кеша

|Стратегия|Почему подходит|Почему не подходит|
|---------|---------------|------------------|
|Временная|Может подойти для товаров во время поиска, поскольку товары не меняются очень часто. Для вывода списка последних заказов тоже подходит, если допустима небольшая задержка в их обработке.|Более подходящим является стратегия по ключу, когда происходят определенные события с конкретным товаром или заказом|
|Инвалидация, основанная на запросах|Подходит при оформлении заказа, также подойдет и для списка заказов, можно добавить функцию Обновить при просмотре, когда будут потдягиваться самые свежие данные с обнровлением кэша|Не подходит для поиска товаров, так как нет запросов на обновление данных|
|Инвалидация на основе изменений|Может подойти для товаров и списка заказов, при изменении данных|Если изменения будут происходить слешком часто, будет повышенная нагрузка на БД и сам кэш. В этом случае лучше использовать инвалидацию по ключу|
|Программная инвалидация||Для простых сценариев достаточно инвалидации на основе изменений|
|Инвалидация по ключу|Позволяет точно определить данные, которые нуждаются в обновлении. Не нагружает систему.||

Таким образом, можно использовать следующие стратегии инвалидации:
* Временная
* Инвалидация, основанная на запросах (только заказы)
* Инвалидация на основе изменений
* Инвалидация по ключу

Однако оптимальной является стратегия по ключу, ее можно комбинировать с временной и валидацией, основанной на запросах (какое событие наступит раньше).
